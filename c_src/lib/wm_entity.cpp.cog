

#include "wm_entity_utils.h"

#include <iostream>

[[[cog

  import sys

  if 'WM_ENTITY_NAME' not in globals():
    cog.error("No WM_ENTITY_NAME defined")
    sys.exit(1)

  ClassName = "Swm" + WM_ENTITY_NAME.title().replace('_', '')
  cog.msg("genareting %s code" % ClassName)

  import json, collections
  json_data=open('./priv/schema.json')
  data = json.load(json_data, object_pairs_hook=collections.OrderedDict)

  sys.path.append("./scripts")
  from autogen_helpers import *


  def transform(schema_type):
    suffix = schema_type
    camel_type = suffix
    is_array = False
    is_struct = False
    if schema_type.startswith('#'):
      (camel_type, suffix, is_struct) = struct_param_type(suffix)
    elif '{' in schema_type and '{}' not in schema_type:
      pp = schema_type[schema_type.find('{') + 1 : schema_type.find('}')].split(',')
      suffix = 'tuple' + get_tuple_type(pp)
    if '[' in schema_type:
      suffix = schema_type[schema_type.find('[') + 1 : schema_type.find(']')]
      if suffix in type_suffix.keys():
        suffix = type_suffix[suffix]
      (tmp1, tmp2, is_struct) = struct_param_type(suffix)
      (suffix, camel_type, _tmp1, _tmp2) = transform(suffix)
      is_array = True
    else:
      if suffix in type_suffix.keys():
        suffix = type_suffix[suffix]
    return (suffix, camel_type, is_array, is_struct)


  def get_final_type(schema_type):
    final_type = schema_type
    if schema_type.startswith('#'):
      (final_type, plain, ignore) = struct_param_type(final_type)
    elif '{' in schema_type:
      pp = schema_type[schema_type.find('{') + 1 : schema_type.find('}')].split(',')
      final_type = c_struct(pp)
    if '[' in schema_type:
      final_type = schema_type[schema_type.find('[') + 1 : schema_type.find(']')]
      if final_type in types.keys():
        final_type = types[final_type]
      param_type = get_final_type(final_type)
      final_type = 'std::vector<' + param_type + '>'
    else:
      if final_type in types.keys():
        final_type = types[final_type]
    return final_type


  def out_init_ctor(x,y):
    outputs = []
    outputs.append("%s::%s() {" % (ClassName, ClassName))
    outputs.append("}")
    outputs.append("")
    outputs.append("%s::%s(ETERM *term) {" % (ClassName, ClassName))
    outputs.append("  if(!term) {")
    outputs.append("    std::cerr << \"Cannot convert ETERM to %s: empty\" << std::endl;" % ClassName)
    outputs.append("    return;")
    outputs.append("  }")
    pos = 2
    includes = set()
    for z,k in y.items():
      is_array = False
      is_struct = False
      if k["type"] in type_suffix.keys():
        ts = type_suffix[k["type"]]
      else:
        (ts, camel_type, is_array, is_struct) = transform(k["type"])
      if is_struct and not is_array:
        term = "erl_element(" + str(pos) + ", term)"
      else:
        term = "term, " + str(pos)
      if is_array:
        outputs.append("  if(eterm_to_" + ts + "(" + term + ", " + z + ")) {")
      else:
        outputs.append("  if(eterm_to_" + ts + "(" + term + ", " + z + ")" + ") {")
      outputs.append("    std::cerr << \"Could not initialize " + x + " paremeter at position " + str(pos) + "\" << std::endl;")
      outputs.append("    erl_print_term(stderr, term);")
      outputs.append("    return;")
      outputs.append("  }")
      pos += 1

      if is_struct:
        includes.add(ts)

    outputs.append("}")
    outputs.append("")
    return (includes, outputs)


  def out_init_array_fun(x,y):
    struct_type = x.title().replace('_', '')
    cog.out("int swm::eterm_to_%s(" % WM_ENTITY_NAME)
    cog.out("ETERM* term, ")
    cog.out("int pos, ")
    cog.out("std::vector<Swm" + struct_type + "> &array")
    cog.out(") {")
    cog.outl()
    cog.outl("  ETERM* elist = erl_element(pos, term);");
    cog.outl("  if(!ERL_IS_LIST(elist)) {");
    cog.outl("    std::cerr << \"Could not parse eterm: not a " + x + " list\" << std::endl;");
    cog.outl("    return -1;");
    cog.outl("  }");
    cog.outl("  if(ERL_IS_EMPTY_LIST(elist)) {");
    cog.outl("    return 0;");
    cog.outl("  }");
    cog.outl("  const size_t sz = erl_length(elist);");
    cog.outl("  array.reserve(sz);");
    cog.outl("  for(size_t i=0; i<sz; ++i) {");
    cog.outl("    ETERM* e = erl_hd(elist);");
    cog.outl("    array.push_back(Swm%s(e));" % struct_type);
    cog.outl("    elist = erl_tl(elist);");
    cog.outl("  }");
    cog.outl("  return 0;");
    cog.outl("}")
    cog.outl()


  def out_convert_fun(x,y):
    struct_type = x.title().replace('_', '')
    cog.out("int swm::eterm_to_%s(" % WM_ENTITY_NAME)
    cog.out("ETERM* eterm, ")
    cog.out("Swm" + struct_type + " &obj")
    cog.outl(") {")
    cog.outl("  obj = Swm%s(eterm);" % struct_type);
    cog.outl("  return 0;");
    cog.outl("}")
    cog.outl()


  def out_print_funs(x,y):
    cog.out("void %s::print(const std::string &prefix, const char separator) const {\n" % ClassName)
    for name,k in y.items():
      (ts, camel_type, is_array, is_struct) = transform(k["type"])
      if is_array:
        cog.outl("  if(" + name + ".empty()) {")
        cog.outl("    std::cerr << prefix << \"" + name + ": []\" << separator;");
        cog.outl("  } else {")
        cog.outl("    std::cerr << prefix << \"" + name + "\" << \": [\";");
        cog.outl("    for(const auto &q: " + name + ") {")
        if is_struct:
          cog.outl("      q.print(prefix, separator);")
        else:
          cog.outl("      std::cerr << q << \",\";")
        cog.outl("    }")
        cog.outl("    std::cerr << \"]\" << separator;");
        cog.outl("  }")
      else:
        if is_struct:
          cog.outl("  " + name + ".print(prefix, separator);")
        else:
          cog.outl("    std::cerr << prefix << " + name + " << separator;")
    cog.outl("  std::cerr << std::endl;");
    cog.outl("}\n")


  def out_setters(x,y):
    need_setters = []
    for z,k in y.items():
      if k["type"] in types.keys():
        type_str = types[k["type"]]
      else:
        type_str = get_final_type(k["type"])
      need_setters.append((z, type_str))
    cog.outl()
    for (x,t) in need_setters:
      cog.outl("void %s::set_%s(const %s &new_val) {" % (ClassName, x, t))
      if t == "ETERM*":
         cog.outl("  %s = const_cast<ETERM*>(new_val);" % x)
      else:
         cog.outl("  %s = new_val;" % x)
      cog.outl("}")
      cog.outl()
    for (x,t) in need_setters:
      cog.outl("%s %s::get_%s() const {" % (t, ClassName, x))
      cog.outl("  return %s;" % x)
      cog.outl("}")
      cog.outl()


  def generate_output():
    for e in exclude:
      del data[e]

    if WM_ENTITY_NAME in data:
      x = WM_ENTITY_NAME
      y = data[WM_ENTITY_NAME]
    else:
      cog.error("No entity '%s' found" % WM_ENTITY_NAME)
      import sys
      sys.exit(1)


    cog.outl("#include \"wm_%s.h\"" % WM_ENTITY_NAME)
    cog.outl()
    cog.outl("#include <erl_interface.h>")
    cog.outl("#include <ei.h>")
    cog.outl()

    (includes, outputs) = out_init_ctor(x,y)
    for include in includes:
      cog.outl('#include "wm_' + include + '.h"')

    cog.outl()
    cog.outl("using namespace swm;")

    cog.outl()
    cog.outl()
    for output in outputs:
      cog.outl(output)
    cog.outl()

    out_setters(x,y)
    cog.outl()

    out_init_array_fun(x,y)
    cog.outl()

    out_convert_fun(x,y)
    cog.outl()

    out_print_funs(x,y)
    cog.outl()


  generate_output()

]]]

