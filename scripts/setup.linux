#!/usr/bin/env python3
#
# Copyright (c) 2016-2018 Sky Workflows. All Rights Reserved.
#
# This software is the confidential and proprietary information of
# Sky Workflows ("Confidential Information"). You shall not
# disclose such Confidential Information and shall use it only in
# accordance with the terms of the license agreement you entered into
# with Sky Workflows or its subsidiaries.

# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

# NOTE: When we run setup.linux then there is no generated sys.config, but only the template.
# Thus the service stopage (in case it was started before) ends with the error "Invalid node name".
# Also the stoppage will fail because old and new cookies may differ. Perhaps we need to consider
# using a single erlang-node name and using a hash of the node name?


import argparse
import datetime
import getpass
import logging
import os
import sys
import shutil
import socket
import time
import uuid

from subprocess import Popen
from subprocess import PIPE


product = "swm"
erts="9.1" # Erlang 20.1

services_dir = "/lib/systemd/system"
log_file = "/tmp/swm-setup.log"
log = logging.getLogger("cm-scale")


def swm_version_dir():
    me = os.path.abspath(__file__)
    return os.path.dirname(os.path.dirname(me))

SWM_VERSION_DIR = swm_version_dir()


def setup_logger(opts):
    global log
    for hdlr in log.handlers[:]:
        log.removeHandler(hdlr)
    fh = logging.FileHandler(log_file)
    fmr = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
    fh.setFormatter(fmr)
    log.addHandler(fh)

    if opts.get("DEBUG", False):
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    ch = logging.StreamHandler(sys.stdout)
    ch.setFormatter(fmr)
    log.addHandler(ch)


def run(exe, args, env, exit_on_fail = True, verbose = True):
    def normalize(x):
        return list(filter(None, x.decode("utf-8", "strict").split("\n")))

    cmdline = exe + ' ' + ' '.join(args)
    log.info("Run " + "'" + cmdline + "'")
    filename = os.path.basename(exe)

    try:
        pipe = Popen(cmdline, shell=True, stdout=PIPE, stderr=PIPE, env=env)
        (stdout, stderr) = pipe.communicate()

        stdout = normalize(stdout)
        stderr = normalize(stderr)

        if verbose:
            for line in stdout:
                log.info("     " + filename + " stdout: " + str(line))
            for line in stderr:
                log.info("     " + filename + " stderr: " + str(line))

        if pipe.wait() != 0:
            if exit_on_fail:
                log.error("     " + filename + " exit code: " + str(pipe.returncode))
                sys.exit(1)
        else:
            log.info("     " + filename + " exit code: " + str(pipe.returncode))
    except Exception as e:
        log.error("     " + filename + " execution: " + e)
        sys.exit(1)
    return (stdout, stderr)


def  write_file(filepath, content):
    try:
        log.info("Write %s" % filepath)
        with open(filepath, "w", encoding='utf-8') as fh:
            fh.write(content)
    except Exception as e:
        log.error("Could not write %s: %s" % (filepath, e))
        sys.exit(1)


def question(msg, default, ispath=True):
    msgfull = (msg + " [%s]: ") % default
    print(msgfull, end="",flush=True)
    answer = sys.stdin.readline()
    answer = answer.strip()
    if len(answer) == 0:
        return default
    if ispath:
        answer = os.path.expanduser(answer)
        answer = os.path.abspath(answer)
        base = os.path.dirname(answer)
        if os.path.isdir(base):
            return answer
        else:
            return default
    return answer


def make_dirs(dir):
    if not os.path.exists(dir):
        try:
            log.info("Making dir: " + dir)
            os.makedirs(dir, 0o700)
        except OSError as e:
            log.error("could not create %s: %s" % (dir, e))
            sys.exit(1)


def backup(opts):
    dir = opts["SWM_SPOOL"]
    if os.path.isdir(dir):
        log.info("Backuping " + dir)
        shutil.move(dir, dir + datetime.datetime.now().isoformat())


def ensure_dirs(opts):
    make_dirs(opts["SWM_SPOOL"])


def generate_configs(opts):
    generate_service_file(opts)


def generate_service_file(opts):
    if opts.get("TESTING", False):
        log.info("Service file will not be installed")
        return
    tmplfp = os.path.join(opts["SWM_PRIV_DIR"], "setup", "systemd-service.linux")
    log.info("service template file: %s" % tmplfp)
    try:
        with open(tmplfp, "r") as f:
            lines = f.readlines()
            template = ''.join(lines)
    except OSError as e:
        log.error("Could not read %s: %s" % (tmplfp, e))
        sys.exit(1)
    script = os.path.join(SWM_VERSION_DIR, "bin", product)
    env = os.path.join(SWM_VERSION_DIR, "scripts", "swm.env")
    log.info("init script path: %s" % script)
    template = template.replace("{SCRIPT}", script)
    template = template.replace("{ENV}", env)
    service_fp = os.path.join(services_dir, product + ".service")
    write_file(service_fp, template)


def env(opts):
    command = ['bash', '-c', 'source {env}'.\
               format(env=os.path.join(SWM_VERSION_DIR, "scripts", "swm.env"))]
    log.info("Run '%s'" % ' '.join(command))

    envs = os.environ
    for (key,val) in opts.items():
        if isinstance(val, str) and key.startswith("SWM"):
            envs[key] = val

    proc = Popen(command, stdout = PIPE, env=envs)
    for line in proc.stdout:
        line = line.decode()
        (key, _, value) = line.partition("=")
        os.environ[key] = value.strip()
    proc.communicate()


def get_div_arg(opts):
    div_arg = "-x"
    if opts["DIVISION"] == "grid":
        div_arg = "-g"
    elif opts["DIVISION"] == "cluster" and not opts["SWM_SKY_PORT"]:
        div_arg = "-c"
    return div_arg

def spawn_vnode(opts):
    if opts["DIVISION"] not in ("grid", "cluster"):
        return

    if opts.get("TESTING", False):
        args = [get_div_arg(opts), "-b"]
        script = os.path.join(SWM_VERSION_DIR, "scripts", "run-in-shell.sh")
    else:
        args = ["start"]
        script = os.path.join(SWM_VERSION_DIR, "bin", product)
        opts["SWM_MNESIA_DIR"] = os.path.join(opts["SWM_SPOOL"],
                                              opts["SWM_SNAME"] + "@" + opts["SWM_HOST"],
                                              "confdb")

    os.environ["SWM_MODE"] = "MAINT"
    envs = os.environ
    for (key,val) in opts.items():
        if isinstance(val, str):
            envs[key] = val
    for key,val in envs.items():
        if key.startswith("SWM"):
            log.info("export %s=%s" % (key, val))

    run(script, args, envs)


def wait_vnode(opts):
    def poll(ping_vnode, n):
        while n > 0:
            (stdout, stderr) = ping_vnode()
            for line in stdout:
                if line == "pong":
                    time.sleep(5)
                    return
            time.sleep(1)
            n = n - 1
        ping_vnode(exit_on_fail = True, verbose = True)

    if opts["DIVISION"] not in ("grid", "cluster"):
        return

    if opts.get("TESTING", False):
        script = os.path.join(SWM_VERSION_DIR, "scripts", "run-in-shell.sh")
        args = [get_div_arg(opts), "-p"]
    else:
        script = os.path.join(SWM_VERSION_DIR, "bin", "swm")
        args = ["ping"]

    poll(lambda exit_on_fail = False, verbose = False: run(script, args, os.environ, exit_on_fail, verbose), 60)


def stop_vnode(opts, exit_on_fail=True):
    if opts["DIVISION"] not in ("grid", "cluster"):
        return

    if opts.get("TESTING", False):
        script = os.path.join(SWM_VERSION_DIR, "scripts", "run-in-shell.sh")
        args = [get_div_arg(opts), "-s"]
        run(script, args, os.environ)
    else:
        script = os.path.join(SWM_VERSION_DIR, "bin", "swm")
        if os.path.exists(script):
            run(script, ["stop"], os.environ, exit_on_fail)


def run_ctl(args, opts):
    if opts.get("TESTING", False):
        ctl = os.path.join(SWM_VERSION_DIR, "scripts", "swmctl")
    else:
        ctl = os.path.join(SWM_VERSION_DIR, "bin", "swmctl")

    envs = os.environ
    for (key,val) in opts.items():
        if isinstance(val, str):
            envs[key] = val

    capath = os.path.join(opts["SWM_SPOOL"], "secure/cluster/cert.pem")
    envs["SWM_CLUSTER_CA"] = capath
    run(ctl, args, envs)


def load_db_configs(opts):
    if opts["DIVISION"] not in ["grid", "cluster"]:
        log.info("Skip loading db configs")
        return

    schema = os.path.join(opts["SWM_PRIV_DIR"], "schema.json")
    run_ctl(["global", "update", "schema", schema], opts)
    base_config = os.path.join(opts["SWM_PRIV_DIR"], "base.config")
    run_ctl(["global", "import", base_config], opts)
    if "EXTRA_CONFIG" in opts:
        run_ctl(["global", "import", opts["EXTRA_CONFIG"]], opts)
    add_default_users(opts)


def run_create_cert(args, opts):
    if opts.get("TESTING", False):
        script = os.path.join(SWM_VERSION_DIR, "scripts", "swm-create-cert")
    else:
        script = os.path.join(SWM_VERSION_DIR, "bin", "swm-create-cert")
    envs = os.environ
    for (key,val) in opts.items():
        if isinstance(val, str):
            envs[key] = val

    run(script, args, envs)


def generate_certificates(opts):
    if opts["DIVISION"] != "grid" and not opts["SWM_SKY_PORT"]:
        log.info("Skip keys generating")
        return
    log.info("Generate certificates")
    run_create_cert(["grid"], opts)
    run_create_cert(["cluster"], opts)
    run_create_cert(["user", opts["SWM_ADMIN_USER"], opts["SWM_ADMIN_ID"]], opts)
    run_create_cert(["host"], opts)
    if opts["SWM_SKY_PORT"]:
        run_create_cert(["skyport"], opts)
    else:
        run_create_cert(["node"], opts)
    install_admin_cert(opts)
    create_chain_cert(opts)


def create_chain_cert(opts):
    filenames = ['/opt/swm/spool/secure/cluster/cert.pem',
                 '/opt/swm/spool/secure/grid/cert.pem']
    with open('/opt/swm/spool/secure/cluster/ca-chain-cert.pem', 'w') as outfile:
        for fname in filenames:
            with open(fname) as infile:
                outfile.write(infile.read())


def install_admin_cert(opts):
    home = os.environ["HOME"]
    if not home:
        log.error("$HOME is not defined")
        sys.exit(1)
    src_dir = os.path.join(opts["SWM_SPOOL"], "secure",
                           "users", opts["SWM_ADMIN_USER"])
    dst_dir = os.path.join(home, ".swm")
    if not os.path.exists(dst_dir):
        try:
            os.makedirs(dst_dir)
        except IOError as e:
            log.error("Cannot create %s: %s" % (dst_dir, e))
            sys.exit(1)

    for file in ["cert.pem", "key.pem"]:
        src = os.path.join(src_dir, file)
        dst = os.path.join(dst_dir, file)

        if os.path.exists(dst):
            log.info("file exists, will be replaced: %s" % dst)
            try:
                os.remove(dst)
            except IOError as e:
                log.error("Cannot remove: %s" % (dst, e))
                sys.exit(1)

        try:
            shutil.copyfile(src, dst, follow_symlinks=True)
        except IOError as e:
            log.error("Cannot copy %s -> %s: %s" % (src, dst, e))
            sys.exit(1)


def add_default_users(opts):
    log.info("Add default users")
    if opts["DIVISION"] not in ["grid", "cluster"]:
        log.info("User will not be added")
        return
    run_ctl(["user", "create", opts["SWM_ADMIN_USER"], opts["SWM_ADMIN_ID"]], opts)


def get_setup_options():
    args = get_args()
    opts = {}
    if args.skyport:
        opts["SWM_SKY_PORT"] = True
    if args.spool:
        opts["SWM_SPOOL"] = args.spool
    if args.division:
        opts["DIVISION"] = args.division
    if args.testing:
        opts["TESTING"] = True # see scripts/setup-dev.linux
        opts["DEBUG"] = True
    if args.archive:
        opts["ARCHIVE"] = True
    if args.extra:
        opts["EXTRA_CONFIG"] = args.extra
    if args.extra and not os.path.exists(args.extra):
        log.error("No such file: " + str(args.extra))
        sys.exit(1)
    if args.prefix:
        if not os.path.exists(args.prefix):
            log.error("No such file: " + str(args.prefix))
            sys.exit(1)
        opts["SWM_ROOT"] = args.prefix
    if args.config:
        if not os.path.isfile(args.config):
            log.error("No such file: " + str(args.config))
            sys.exit(1)
        try:
            fp = open(args.config, "rt")
            while True:
                line = fp.readline()
                if not line:
                    break
                line = line.strip()
                if len(line) == 0:
                    continue
                if line[0] == "#":
                    continue
                pp = line.split("=")
                if len(pp) < 2:
                    continue
                key = pp[0].strip().replace('"', "").replace("'", "")
                val = pp[1].strip().replace('"', "").replace("'", "")
                if len(key) and len(val):
                    opts[key] = val
        except IOError as e:
            log.error("Cannot read %s: %s" % (args.config, e))
            sys.exit(1)
    return opts


def get_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-d", "--division",
        default='node',
        choices=['grid', 'cluster'],
        help="Configuring division name"
    )

    parser.add_argument(
        "-p", "--prefix",
        help="Path to root directory (can also be defined with $SWM_ROOT)"
    )

    parser.add_argument(
        "-s", "--spool",
        help="Path to spool directory (can also be defined with $SWM_SPOOL, "
             "if not set, then $SWM_ROOT/spool is used)"
    )

    parser.add_argument(
        "-c", "--config",
        help="Path to file with default setup options"
    )

    parser.add_argument(
        "-e", "--extra",
        help="Path to file with additional DB configuration"
    )

    parser.add_argument(
        "-t", "--testing",
        action="store_true",
        help="Setup for testing purposes (no servicefile, just a spool)"
    )

    parser.add_argument(
        "-x", "--skyport",
        action="store_true",
        help="Setup Sky Port"
    )

    parser.add_argument(
        "-v", "--version",
        help="Specify version"
    )

    parser.add_argument(
        "-a", "--archive",
        help="Generate final worker SWM archive"
    )

    return parser.parse_args()


def userInput(env, default, descr, opts, replacements=[], ispath=True):
    if env not in opts:
        answer = question("Enter " + descr, default, ispath)
        opts[env] = answer
    for (x,y) in replacements:
        opts[env] = opts[env].replace(x, y)
    log.info("Entered " + descr + ": " + opts[env])


def set_default(env, default, descr, opts):
    if env not in opts:
        opts[env] = default
    os.environ[env] = opts[env]
    log.info("Using " + descr + ": " + opts[env])


def get_defaults(opts):
    set_default("SWM_VERSION",     os.environ["SWM_VERSION"],             "version",                   opts)

    set_default("SWM_ROOT",        os.environ["SWM_ROOT"],                "product directory",         opts)
    set_default("SWM_SPOOL",       os.environ["SWM_SPOOL"],               "product spool directory",   opts)

    set_default("SWM_PRIV_DIR",    os.path.join(SWM_VERSION_DIR, "priv"), "priv directory",            opts)

    if "EXTRA_CONFIG" not in opts:
        if opts["DIVISION"] == "grid":
            opts["EXTRA_CONFIG"] = os.path.join(opts["SWM_PRIV_DIR"], "setup", "grid.config")
        elif opts["DIVISION"] == "cluster":
            conf = "skyport.config" if opts["SWM_SKY_PORT"] else "cluster.config"
            opts["EXTRA_CONFIG"] = os.path.join(opts["SWM_PRIV_DIR"], "setup", conf)

    if "SWM_SNAME" not in opts:
        division = opts.get("DIVISION", "")
        if division == 'grid':
            opts["SWM_SNAME"] = "ghead"
        elif division == 'cluster':
            opts["SWM_SNAME"] = "sp1" if opts["SWM_SKY_PORT"] else "chead1"
        else:
            opts["SWM_SNAME"] = division


def get_from_user(opts):
    default_port = "10001" if opts.get("DIVISION", "") == "grid" else "10011"
    if "SWM_API_PORT" not in opts:
        opts["SWM_API_PORT"] = default_port
    userInput("SWM_API_PORT", default_port, "API port", opts)

    hostname = socket.gethostname()
    userInput("SWM_SNAME", "ghead" + "@" + hostname,
              "Division management vnode name", opts, [("{HOSTNAME}", hostname)], False)
    userInput("SWM_HOST", hostname, "Division management host name", opts,
              [("{HOSTNAME}", hostname)], False)

    admin = getpass.getuser()
    opts["SWM_ADMIN_ID"] = str(uuid.uuid4())
    userInput("SWM_ADMIN_USER", admin, "administrator user", opts,
              [("{USER}", admin)], False)
    userInput("SWM_ADMIN_EMAIL", opts["SWM_ADMIN_USER"]+"@"+opts["SWM_HOST"],
              "administrator email", opts, [("{USER}", admin)], False)

    userInput("SWM_UNIT_NAME", "Dev", "organizational unit name", opts, ispath=False)
    userInput("SWM_ORG_NAME", "Sky Workflows", "organization name", opts, ispath=False)
    userInput("SWM_LOCALITY", "EN", "locality name", opts, ispath=False)
    userInput("SWM_COUNTRY", "US", "country name", opts, ispath=False)


def create_archive(opts):
    if opts.get("TESTING", False):
        log.info("Archive will not be created")
        return
    root_dir    = opts["SWM_ROOT"]
    swm_dir     = os.path.join(root_dir, opts["SWM_VERSION"])
    spool_dir   = opts["SWM_SPOOL"]
    swm_version = opts["SWM_VERSION"]

    files = [swm_dir,
             os.path.join(spool_dir, "secure/cluster"),
             os.path.join(spool_dir, "secure/node"),
             os.path.join(spool_dir, "secure/users")]

    for f in files:
        if not os.path.isdir(f):
            log.error("No such file: " + f)
            sys.exit(1)

    archive = "{root_dir}/{product}-{version}-worker.tar.gz".format(root_dir=root_dir, product=product, version=swm_version)
    script = "tar"
    args = ["--transform", "'s,^.*\/swm/,,'", "-czf", archive, " ".join(files)]

    run(script, args, os.environ)

    log.info("Final worker SWM archive: " + archive)


def symlink_to_current(opts):
    if opts.get("TESTING", False):
        log.info("Do not create a symlink 'current'")
        return

    root_dir = opts["SWM_ROOT"]

    src = os.path.join(root_dir, opts["SWM_VERSION"])
    dst = os.path.join(root_dir, "current")

    if os.path.exists(dst):
        os.unlink(dst)
    os.symlink(src, dst)

    log.info("Create symlink %s -> %s" % (dst, src))


def final_message(opts):
    print("SWM for %s has been installed" % opts["DIVISION"])


def main():
    opts = get_setup_options()
    setup_logger(opts)

    env(opts)
    get_defaults(opts)

    if opts.get("ARCHIVE", False):
        create_archive(opts)
    else:
        get_from_user(opts)
        stop_vnode(opts, exit_on_fail=False)
        #backup(opts)
        ensure_dirs(opts)
        generate_configs(opts)
        generate_certificates(opts)
        spawn_vnode(opts)
        wait_vnode(opts)
        load_db_configs(opts)
        stop_vnode(opts)
        create_archive(opts)
        symlink_to_current(opts)

    final_message(opts)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
        sys.exit(0)

